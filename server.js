const WebSocket = require('ws');
const OBSWebSocket = require('obs-websocket-js').default;
const fs = require('fs');
const path = require('path');
const { exec, spawn } = require('child_process');

class VideoMasterServer {
    constructor() {
        this.port = 3001;
        this.obsPort = 4455;
        this.obsAddress = 'localhost';
        this.obsPassword = '';
        
        // WebSocket servers
        this.wss = null;
        this.clients = new Set();
        
        // OBS connection
        this.obs = new OBSWebSocket();
        this.obsConnected = false;
        
        // Recording state
        this.isRecording = false;
        this.currentBlockIndex = 0;
        this.recordingFiles = [];
        this.projectPath = '';
        this.currentRecordingFile = null;
        this.lastRecordingPath = null; // –ü–æ–ª–Ω—ã–π –ø—É—Ç—å –∫ –ø–æ—Å–ª–µ–¥–Ω–µ–π –∑–∞–ø–∏—Å–∏
        
        // Settings
        this.settings = {
            videoFormat: 'mp4',
            videoQuality: 'high',
            outputPath: this.getDefaultOutputPath()
        };
        
        // FFmpeg path detection
        this.ffmpegPath = this.findFFmpegPath();
        
        this.initializeServer();
    }

    findFFmpegPath() {
        // Check local ffmpeg.exe first
        const localFFmpeg = path.join(process.cwd(), 'ffmpeg.exe');
        if (fs.existsSync(localFFmpeg)) {
            console.log('‚úÖ Found local FFmpeg:', localFFmpeg);
            return localFFmpeg;
        }
        
        // Check if ffmpeg is in PATH
        try {
            exec('ffmpeg -version', (error) => {
                if (!error) {
                    console.log('‚úÖ FFmpeg found in system PATH');
                } else {
                    console.log('‚ùå FFmpeg not found in PATH');
                }
            });
            return 'ffmpeg';
        } catch (error) {
            console.log('‚ùå FFmpeg not found anywhere');
            return null;
        }
    }

    initializeServer() {
        console.log('üé¨ Initializing Video Master Server...');
        console.log('üìÅ Output directory:', this.settings.outputPath);
        console.log('üîß FFmpeg path:', this.ffmpegPath || 'NOT FOUND');
        
        // Create WebSocket server
        this.wss = new WebSocket.Server({ port: this.port });
        
        this.wss.on('connection', (ws) => {
            console.log('üì° Client connected');
            this.clients.add(ws);
            
            ws.on('message', (message) => {
                this.handleClientMessage(ws, JSON.parse(message));
            });
            
            ws.on('close', () => {
                console.log('üì° Client disconnected');
                this.clients.delete(ws);
            });
            
            ws.on('error', (error) => {
                console.error('WebSocket error:', error);
                this.clients.delete(ws);
            });
        });
        
        // Setup OBS event handlers
        this.setupOBSHandlers();
        
        console.log(`üöÄ Video Master Server running on port ${this.port}`);
        console.log('üìã Available commands:');
        console.log('   - connect_obs: Connect to OBS Studio');
        console.log('   - start_recording: Start recording a block');
        console.log('   - stop_recording: Stop recording');
        console.log('   - test_recording: Test 5-second recording');
        console.log('   - merge_videos: Combine all block videos');
    }

    setupOBSHandlers() {
        this.obs.on('ConnectionOpened', () => {
            console.log('‚úÖ Connected to OBS Studio');
            this.obsConnected = true;
            this.broadcastOBSStatus();
        });
        
        this.obs.on('ConnectionClosed', () => {
            console.log('‚ùå Disconnected from OBS Studio');
            this.obsConnected = false;
            this.broadcastOBSStatus();
        });
        
        this.obs.on('RecordStateChanged', (data) => {
            console.log('üìπ Recording state changed:', {
                outputActive: data.outputActive,
                outputPath: data.outputPath,
                outputBytes: data.outputBytes,
                outputTimecode: data.outputTimecode
            });
            
            if (data.outputActive) {
                // Recording started
                this.currentRecordingFile = path.basename(data.outputPath);
                this.lastRecordingPath = data.outputPath;
                this.isRecording = true;
                
                console.log('üé¨ ===== –ó–ê–ü–ò–°–¨ –ù–ê–ß–ê–¢–ê =====');
                console.log('   üìÅ –§–∞–π–ª:', this.currentRecordingFile);
                console.log('   üìÇ –ü–æ–ª–Ω—ã–π –ø—É—Ç—å:', this.lastRecordingPath);
                console.log('   üéØ –ë–ª–æ–∫:', this.currentBlockIndex + 1);
                console.log('================================');
                
                this.broadcastToClients({
                    type: 'recording_started',
                    data: { 
                        filename: this.currentRecordingFile,
                        fullPath: this.lastRecordingPath,
                        blockIndex: this.currentBlockIndex
                    }
                });
            } else {
                // Recording stopped
                this.isRecording = false;
                const finalFile = this.currentRecordingFile;
                const finalPath = this.lastRecordingPath;
                
                console.log('‚èπÔ∏è ===== –ó–ê–ü–ò–°–¨ –û–°–¢–ê–ù–û–í–õ–ï–ù–ê =====');
                console.log('   üìÅ –§–∞–π–ª:', finalFile);
                console.log('   üìÇ –ü–æ–ª–Ω—ã–π –ø—É—Ç—å:', finalPath);
                console.log('   üéØ –ë–ª–æ–∫:', this.currentBlockIndex + 1);
                console.log('   üìä –†–∞–∑–º–µ—Ä:', data.outputBytes ? `${(data.outputBytes / 1024 / 1024).toFixed(2)} MB` : '–Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω');
                console.log('   ‚è±Ô∏è –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:', data.outputTimecode || '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞');
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ñ–∞–π–ª –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —Å–æ–∑–¥–∞–Ω
                if (finalPath && require('fs').existsSync(finalPath)) {
                    const stats = require('fs').statSync(finalPath);
                    console.log('   ‚úÖ –§–∞–π–ª –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω, —Ä–∞–∑–º–µ—Ä:', (stats.size / 1024 / 1024).toFixed(2), 'MB');
                } else {
                    console.log('   ‚ùå –í–ù–ò–ú–ê–ù–ò–ï: –§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω!');
                }
                console.log('====================================');
                
                this.broadcastToClients({
                    type: 'recording_stopped',
                    data: { 
                        filename: finalFile,
                        fullPath: finalPath,
                        blockIndex: this.currentBlockIndex,
                        outputBytes: data.outputBytes,
                        outputTimecode: data.outputTimecode,
                        fileExists: finalPath ? require('fs').existsSync(finalPath) : false
                    }
                });
                
                // –ù–ï –æ—á–∏—â–∞–µ–º currentRecordingFile - –æ—Å—Ç–∞–≤–ª—è–µ–º –¥–ª—è –ø—Ä–∏–Ω—è—Ç–∏—è —Ä–µ—à–µ–Ω–∏—è
                // this.currentRecordingFile = null;
            }
        });
        
        this.obs.on('ConnectionError', (error) => {
            console.error('‚ùå OBS connection error:', error);
            this.obsConnected = false;
            this.broadcastOBSStatus(error.message);
        });
    }

    async handleClientMessage(ws, message) {
        try {
            console.log('üì® Received message:', message.type, message.data);
            
            switch (message.type) {
                case 'connect_obs':
                    await this.connectToOBS(message.data);
                    break;
                    
                case 'start_recording':
                    await this.startRecording(message.data);
                    break;
                    
                case 'stop_recording':
                    await this.stopRecording();
                    break;
                    
                case 'test_recording':
                    await this.testRecording();
                    break;
                    
                case 'refresh_settings':
                    await this.refreshOBSSettings();
                    break;
                    
                case 'merge_videos':
                    await this.mergeVideos(message.data);
                    break;
                    
                case 'open_video_folder':
                    this.openVideoFolder();
                    break;
                    
                default:
                    console.log('‚ùì Unknown message type:', message.type);
            }
        } catch (error) {
            console.error('‚ùå Error handling message:', error);
            this.sendToClient(ws, {
                type: 'error',
                message: error.message
            });
        }
    }

    async connectToOBS(data) {
        try {
            this.obsAddress = data.address.replace('ws://', '').replace('wss://', '');
            this.obsPassword = data.password;
            
            const [host, port] = this.obsAddress.split(':');
            
            console.log(`üîó Connecting to OBS at ${host}:${port || 4455}...`);
            
            await this.obs.connect(`ws://${host}:${port || 4455}`, this.obsPassword);
            
        } catch (error) {
            console.error('‚ùå Failed to connect to OBS:', error);
            this.obsConnected = false;
            this.broadcastOBSStatus(error.message);
        }
    }

    async refreshOBSSettings() {
        if (!this.obsConnected) {
            throw new Error('OBS not connected');
        }
        
        try {
            // Get scenes
            const scenesResponse = await this.obs.call('GetSceneList');
            const scenes = scenesResponse.scenes.map(scene => scene.sceneName);
            const currentScene = scenesResponse.currentProgramSceneName;
            
            // Get audio sources
            const inputsResponse = await this.obs.call('GetInputList');
            const audioSources = inputsResponse.inputs
                .filter(input => input.inputKind.includes('audio'))
                .map(input => input.inputName);
            
            // Get recording settings
            const recordResponse = await this.obs.call('GetRecordDirectory');
            const recordingPath = recordResponse.recordDirectory;
            
            this.broadcastOBSStatus(null, {
                scenes,
                currentScene,
                audioSources,
                recordingPath
            });
            
        } catch (error) {
            console.error('‚ùå Error refreshing OBS settings:', error);
            throw error;
        }
    }

    async startRecording(data) {
        if (!this.obsConnected) {
            throw new Error('OBS not connected');
        }
        
        try {
            this.currentBlockIndex = data.blockIndex;
            
            console.log(`üé¨ Starting recording for block ${this.currentBlockIndex + 1}:`);
            console.log('   Block text:', data.blockText?.substring(0, 100) + '...');
            
            // Set recording directory
            await this.obs.call('SetRecordDirectory', {
                recordDirectory: this.settings.outputPath
            });
            
            // Start recording
            await this.obs.call('StartRecord');
            
            console.log(`‚úÖ Recording command sent for block ${this.currentBlockIndex + 1}`);
            
        } catch (error) {
            console.error('‚ùå Error starting recording:', error);
            throw error;
        }
    }

    async stopRecording() {
        if (!this.obsConnected) {
            console.log('‚ö†Ô∏è OBS not connected, cannot stop recording');
            return;
        }
        
        try {
            console.log(`‚èπÔ∏è Stopping recording for block ${this.currentBlockIndex + 1}...`);
            
            await this.obs.call('StopRecord');
            
            console.log(`‚úÖ Stop recording command sent for block ${this.currentBlockIndex + 1}`);
            
        } catch (error) {
            console.error('‚ùå Error stopping recording:', error);
            throw error;
        }
    }

    async testRecording() {
        if (!this.obsConnected) {
            throw new Error('OBS not connected');
        }
        
        try {
            console.log('üß™ Starting test recording for 5 seconds...');
            
            await this.obs.call('StartRecord');
            
            setTimeout(async () => {
                try {
                    await this.obs.call('StopRecord');
                    console.log('‚úÖ Test recording completed');
                } catch (error) {
                    console.error('‚ùå Error stopping test recording:', error);
                }
            }, 5000);
            
        } catch (error) {
            console.error('‚ùå Error starting test recording:', error);
            throw error;
        }
    }

    async mergeVideos(data) {
        const { blocks, projectName } = data;
        
        console.log('üîß ===== –ù–ê–ß–ê–õ–û –°–ö–õ–ï–ô–ö–ò =====');
        console.log('üìã –ë–ª–æ–∫–∏ –¥–ª—è —Å–∫–ª–µ–π–∫–∏:', blocks);
        console.log('üìÑ –ò–º—è –ø—Ä–æ–µ–∫—Ç–∞:', projectName);
        console.log('üóÇÔ∏è –ü–∞–ø–∫–∞ –≤—ã–≤–æ–¥–∞:', this.settings.outputPath);
        
        if (!this.ffmpegPath) {
            throw new Error('FFmpeg not found. Please install FFmpeg or place ffmpeg.exe in the project folder.');
        }
        
        // Filter out empty blocks and check if files exist
        const videoDir = this.settings.outputPath;
        const validBlocks = blocks.filter(block => {
            if (!block || block.includes('[–æ—Ç–∫–ª–æ–Ω–µ–Ω]')) {
                console.log(`‚ùå –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π –±–ª–æ–∫: ${block}`);
                return false;
            }
            const filePath = path.join(videoDir, block);
            const exists = fs.existsSync(filePath);
            console.log(`üìÅ –ü—Ä–æ–≤–µ—Ä–∫–∞ ${block}: ${exists ? '‚úÖ –Ω–∞–π–¥–µ–Ω' : '‚ùå –Ω–µ –Ω–∞–π–¥–µ–Ω'}`);
            if (exists) {
                const stats = fs.statSync(filePath);
                console.log(`   –†–∞–∑–º–µ—Ä: ${(stats.size / 1024 / 1024).toFixed(2)} MB`);
            }
            return exists;
        });
        
        if (validBlocks.length === 0) {
            console.log('üìÅ –°–æ–¥–µ—Ä–∂–∏–º–æ–µ –ø–∞–ø–∫–∏ —Å –≤–∏–¥–µ–æ:');
            try {
                const files = fs.readdirSync(videoDir);
                files.forEach(file => {
                    const filePath = path.join(videoDir, file);
                    if (fs.existsSync(filePath)) {
                        const stats = fs.statSync(filePath);
                        console.log(`   üìÑ ${file} (${(stats.size / 1024 / 1024).toFixed(2)} MB)`);
                    }
                });
            } catch (error) {
                console.log('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å –ø–∞–ø–∫—É —Å –≤–∏–¥–µ–æ');
            }
            throw new Error('–ù–µ—Ç –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã—Ö –≤–∏–¥–µ–æ—Ñ–∞–π–ª–æ–≤ –¥–ª—è —Å–∫–ª–µ–π–∫–∏');
        }
        
        console.log(`‚úÖ –ù–∞–π–¥–µ–Ω–æ ${validBlocks.length} –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã—Ö –±–ª–æ–∫–æ–≤ –¥–ª—è —Å–∫–ª–µ–π–∫–∏`);
        
        try {
            const outputFile = path.join(videoDir, `${projectName}.mp4`);
            console.log('üéØ –§–∏–Ω–∞–ª—å–Ω—ã–π —Ñ–∞–π–ª:', outputFile);
            
            if (validBlocks.length === 1) {
                // Single file, just copy
                const inputFile = path.join(videoDir, validBlocks[0]);
                console.log('üìã –û–±–Ω–∞—Ä—É–∂–µ–Ω –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π —Ñ–∞–π–ª, –∫–æ–ø–∏—Ä—É–µ–º –≤–º–µ—Å—Ç–æ —Å–∫–ª–µ–π–∫–∏...');
                fs.copyFileSync(inputFile, outputFile);
                console.log('‚úÖ –ï–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π –≤–∏–¥–µ–æ—Ñ–∞–π–ª —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω —É—Å–ø–µ—à–Ω–æ');
            } else {
                // Multiple files, merge with FFmpeg
                console.log(`üîß –°–∫–ª–µ–π–∫–∞ ${validBlocks.length} —Ñ–∞–π–ª–æ–≤ —Å –ø–æ–º–æ—â—å—é FFmpeg...`);
                await this.mergeWithFFmpeg(validBlocks, outputFile);
            }
            
            // Check if output file was created successfully
            if (fs.existsSync(outputFile)) {
                const stats = fs.statSync(outputFile);
                console.log('üéâ ===== –°–ö–õ–ï–ô–ö–ê –ó–ê–í–ï–†–®–ï–ù–ê =====');
                console.log(`‚úÖ –§–∏–Ω–∞–ª—å–Ω–æ–µ –≤–∏–¥–µ–æ —Å–æ–∑–¥–∞–Ω–æ: ${outputFile}`);
                console.log(`üìä –†–∞–∑–º–µ—Ä: ${(stats.size / 1024 / 1024).toFixed(2)} MB`);
                console.log(`üß© –ë–ª–æ–∫–æ–≤ —Å–∫–ª–µ–µ–Ω–æ: ${validBlocks.length}`);
                console.log('===============================');
                
                this.broadcastToClients({
                    type: 'video_merged',
                    data: { 
                        outputFile,
                        fileSize: stats.size,
                        blocksCount: validBlocks.length,
                        outputPath: this.settings.outputPath
                    }
                });
                
                // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ—Ç–∫—Ä—ã–≤–∞–µ–º –ø–∞–ø–∫—É
                this.openVideoFolder();
                
            } else {
                throw new Error('–í—ã—Ö–æ–¥–Ω–æ–π —Ñ–∞–π–ª –Ω–µ –±—ã–ª —Å–æ–∑–¥–∞–Ω');
            }
            
        } catch (error) {
            console.error('‚ùå –û—à–∏–±–∫–∞ —Å–∫–ª–µ–π–∫–∏ –≤–∏–¥–µ–æ:', error);
            
            // Try alternative merge method
            console.log('üîÑ –ü–æ–ø—ã—Ç–∫–∞ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–æ–≥–æ –º–µ—Ç–æ–¥–∞ —Å–∫–ª–µ–π–∫–∏...');
            try {
                const altOutputFile = path.join(videoDir, `${projectName}_alt.mp4`);
                await this.mergeVideosAlternative(validBlocks, altOutputFile);
                
                if (fs.existsSync(altOutputFile)) {
                    const stats = fs.statSync(altOutputFile);
                    console.log(`‚úÖ –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞—è —Å–∫–ª–µ–π–∫–∞ —É—Å–ø–µ—à–Ω–∞: ${altOutputFile}`);
                    console.log(`   –†–∞–∑–º–µ—Ä: ${(stats.size / 1024 / 1024).toFixed(2)} MB`);
                    
                    this.broadcastToClients({
                        type: 'video_merged',
                        data: { 
                            outputFile: altOutputFile,
                            fileSize: stats.size,
                            blocksCount: validBlocks.length,
                            method: 'alternative',
                            outputPath: this.settings.outputPath
                        }
                    });
                    
                    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ—Ç–∫—Ä—ã–≤–∞–µ–º –ø–∞–ø–∫—É
                    this.openVideoFolder();
                    
                } else {
                    throw new Error('–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞—è —Å–∫–ª–µ–π–∫–∞ —Ç–∞–∫–∂–µ –Ω–µ —Å–º–æ–≥–ª–∞ —Å–æ–∑–¥–∞—Ç—å –≤—ã—Ö–æ–¥–Ω–æ–π —Ñ–∞–π–ª');
                }
            } catch (altError) {
                console.error('‚ùå –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞—è —Å–∫–ª–µ–π–∫–∞ —Ç–∞–∫–∂–µ –Ω–µ —É–¥–∞–ª–∞—Å—å:', altError);
                throw new Error(`–°–∫–ª–µ–π–∫–∞ –Ω–µ —É–¥–∞–ª–∞—Å—å: ${error.message}. –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –º–µ—Ç–æ–¥ —Ç–∞–∫–∂–µ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª: ${altError.message}`);
            }
        }
    }

    async mergeWithFFmpeg(videoFiles, outputFile) {
        return new Promise((resolve, reject) => {
            const videoDir = this.settings.outputPath;
            
            // Create file list for FFmpeg (with proper Windows path escaping)
            const listFile = path.join(videoDir, 'filelist.txt');
            const fileList = videoFiles.map(file => {
                const fullPath = path.join(videoDir, file);
                // Convert Windows paths to forward slashes for FFmpeg
                const ffmpegPath = fullPath.replace(/\\/g, '/');
                return `file '${ffmpegPath}'`;
            }).join('\n');
            
            console.log('üìù Creating filelist.txt:');
            console.log(fileList);
            
            fs.writeFileSync(listFile, fileList, 'utf8');
            
            // Build FFmpeg command with proper quoting
            const ffmpegCmd = `"${this.ffmpegPath}" -f concat -safe 0 -i "${listFile}" -c copy "${outputFile}"`;
            
            console.log('üé¨ Running FFmpeg command:');
            console.log(ffmpegCmd);
            
            exec(ffmpegCmd, (error, stdout, stderr) => {
                // Clean up temp file
                try {
                    fs.unlinkSync(listFile);
                    console.log('üóëÔ∏è Cleaned up temporary filelist.txt');
                } catch (cleanupError) {
                    console.log('‚ö†Ô∏è Could not delete temp file:', cleanupError.message);
                }
                
                if (error) {
                    console.error('‚ùå FFmpeg error:', error.message);
                    console.error('üìã FFmpeg stderr:', stderr);
                    reject(new Error(`FFmpeg failed: ${error.message}`));
                } else {
                    console.log('‚úÖ Videos merged successfully with concat method');
                    if (stdout) console.log('üìã FFmpeg stdout:', stdout);
                    resolve();
                }
            });
        });
    }

    async mergeVideosAlternative(videoFiles, outputFile) {
        return new Promise((resolve, reject) => {
            const videoDir = this.settings.outputPath;
            
            // Alternative method: using filter_complex
            const inputs = videoFiles.map((file, index) => {
                const fullPath = path.join(videoDir, file);
                return `-i "${fullPath}"`;
            }).join(' ');
            
            const filterComplex = videoFiles.map((_, index) => `[${index}:v][${index}:a]`).join('') + 
                                 `concat=n=${videoFiles.length}:v=1:a=1[outv][outa]`;
            
            const ffmpegCmd = `"${this.ffmpegPath}" ${inputs} -filter_complex "${filterComplex}" -map "[outv]" -map "[outa]" "${outputFile}"`;
            
            console.log('üîÑ Running alternative FFmpeg command (filter_complex):');
            console.log(ffmpegCmd);
            
            exec(ffmpegCmd, (error, stdout, stderr) => {
                if (error) {
                    console.error('‚ùå Alternative FFmpeg error:', error.message);
                    console.error('üìã Alternative FFmpeg stderr:', stderr);
                    reject(new Error(`Alternative FFmpeg failed: ${error.message}`));
                } else {
                    console.log('‚úÖ Videos merged successfully with filter_complex method');
                    if (stdout) console.log('üìã Alternative FFmpeg stdout:', stdout);
                    resolve();
                }
            });
        });
    }

    openVideoFolder() {
        const platform = process.platform;
        let command;
        
        switch (platform) {
            case 'win32':
                command = `explorer "${this.settings.outputPath}"`;
                break;
            case 'darwin':
                command = `open "${this.settings.outputPath}"`;
                break;
            case 'linux':
                command = `xdg-open "${this.settings.outputPath}"`;
                break;
            default:
                console.log('üìÅ Video folder:', this.settings.outputPath);
                return;
        }
        
        exec(command, (error) => {
            if (error) {
                console.error('‚ùå Error opening folder:', error);
            } else {
                console.log('üìÅ Opened video folder');
            }
        });
    }

    broadcastOBSStatus(error = null, additionalData = {}) {
        const statusData = {
            connected: this.obsConnected,
            error: error,
            ...additionalData
        };
        
        this.broadcastToClients({
            type: 'obs_status',
            data: statusData
        });
    }

    broadcastToClients(message) {
        const messageStr = JSON.stringify(message);
        this.clients.forEach(client => {
            if (client.readyState === WebSocket.OPEN) {
                client.send(messageStr);
            }
        });
    }

    sendToClient(client, message) {
        if (client.readyState === WebSocket.OPEN) {
            client.send(JSON.stringify(message));
        }
    }

    getDefaultOutputPath() {
        const os = require('os');
        const defaultPath = path.join(os.homedir(), 'Videos', 'VideoMaster');
        
        // Create directory if it doesn't exist
        if (!fs.existsSync(defaultPath)) {
            fs.mkdirSync(defaultPath, { recursive: true });
            console.log('üìÅ Created video directory:', defaultPath);
        }
        
        return defaultPath;
    }
}

// Start server
const server = new VideoMasterServer();

// Handle graceful shutdown
process.on('SIGINT', async () => {
    console.log('\nüõë Shutting down Video Master Server...');
    
    if (server.obsConnected) {
        try {
            await server.obs.disconnect();
        } catch (error) {
            console.error('‚ùå Error disconnecting from OBS:', error);
        }
    }
    
    if (server.wss) {
        server.wss.close();
    }
    
    process.exit(0);
});

module.exports = VideoMasterServer;